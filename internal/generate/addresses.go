//go:build ignore

package main

import (
	"context"
	"fmt"
	"os"
	"strings"
	"text/template"
	"time"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
)

// root of trust - only these addresses are hardcoded
var (
	fwssMainnet     = common.HexToAddress("0x8408502033C418E1bbC97cE9ac48E5528F371A9f")
	fwssCalibration = common.HexToAddress("0x02925630df557F957f70E112bA06e50965417CA0")

	rpcMainnet     = "https://api.node.glif.io/rpc/v1"
	rpcCalibration = "https://api.calibration.node.glif.io/rpc/v1"
)

// view functions on FWSS contract
var fwssABI = `[
	{"type":"function","name":"paymentsContractAddress","inputs":[],"outputs":[{"name":"","type":"address"}],"stateMutability":"view"},
	{"type":"function","name":"viewContractAddress","inputs":[],"outputs":[{"name":"","type":"address"}],"stateMutability":"view"},
	{"type":"function","name":"pdpVerifierAddress","inputs":[],"outputs":[{"name":"","type":"address"}],"stateMutability":"view"},
	{"type":"function","name":"serviceProviderRegistry","inputs":[],"outputs":[{"name":"","type":"address"}],"stateMutability":"view"},
	{"type":"function","name":"sessionKeyRegistry","inputs":[],"outputs":[{"name":"","type":"address"}],"stateMutability":"view"}
]`

type networkAddresses struct {
	FWSS               common.Address
	Payments           common.Address
	StateView          common.Address
	PDPVerifier        common.Address
	SPRegistry         common.Address
	SessionKeyRegistry common.Address
}

func readAddresses(ctx context.Context, rpcURL string, fwssAddr common.Address) (*networkAddresses, error) {
	client, err := ethclient.DialContext(ctx, rpcURL)
	if err != nil {
		return nil, fmt.Errorf("dial rpc: %w", err)
	}
	defer client.Close()

	parsed, err := abi.JSON(strings.NewReader(fwssABI))
	if err != nil {
		return nil, fmt.Errorf("parse abi: %w", err)
	}

	callView := func(method string) (common.Address, error) {
		data, err := parsed.Pack(method)
		if err != nil {
			return common.Address{}, fmt.Errorf("pack %s: %w", method, err)
		}

		result, err := client.CallContract(ctx, ethereum.CallMsg{
			To:   &fwssAddr,
			Data: data,
		}, nil)
		if err != nil {
			return common.Address{}, fmt.Errorf("call %s: %w", method, err)
		}

		var addr common.Address
		if err := parsed.UnpackIntoInterface(&addr, method, result); err != nil {
			return common.Address{}, fmt.Errorf("unpack %s: %w", method, err)
		}
		return addr, nil
	}

	addrs := &networkAddresses{FWSS: fwssAddr}

	addrs.Payments, err = callView("paymentsContractAddress")
	if err != nil {
		return nil, err
	}

	addrs.StateView, err = callView("viewContractAddress")
	if err != nil {
		return nil, err
	}

	addrs.PDPVerifier, err = callView("pdpVerifierAddress")
	if err != nil {
		return nil, err
	}

	addrs.SPRegistry, err = callView("serviceProviderRegistry")
	if err != nil {
		return nil, err
	}

	addrs.SessionKeyRegistry, err = callView("sessionKeyRegistry")
	if err != nil {
		return nil, err
	}

	return addrs, nil
}

var tmpl = template.Must(template.New("addresses").Parse(`// Code generated by go generate; DO NOT EDIT.
// Source: FWSS contracts on mainnet and calibration

package constants

import "github.com/ethereum/go-ethereum/common"

// root of trust - FWSS contract addresses
var (
	FWSSAddressMainnet     = common.HexToAddress("{{ .Mainnet.FWSS.Hex }}")
	FWSSAddressCalibration = common.HexToAddress("{{ .Calibration.FWSS.Hex }}")
)

// derived addresses - read from FWSS contracts
var (
	PaymentsAddresses = map[Network]common.Address{
		NetworkMainnet:     common.HexToAddress("{{ .Mainnet.Payments.Hex }}"),
		NetworkCalibration: common.HexToAddress("{{ .Calibration.Payments.Hex }}"),
	}

	WarmStorageStateViewAddresses = map[Network]common.Address{
		NetworkMainnet:     common.HexToAddress("{{ .Mainnet.StateView.Hex }}"),
		NetworkCalibration: common.HexToAddress("{{ .Calibration.StateView.Hex }}"),
	}

	PDPVerifierAddresses = map[Network]common.Address{
		NetworkMainnet:     common.HexToAddress("{{ .Mainnet.PDPVerifier.Hex }}"),
		NetworkCalibration: common.HexToAddress("{{ .Calibration.PDPVerifier.Hex }}"),
	}

	SPRegistryAddresses = map[Network]common.Address{
		NetworkMainnet:     common.HexToAddress("{{ .Mainnet.SPRegistry.Hex }}"),
		NetworkCalibration: common.HexToAddress("{{ .Calibration.SPRegistry.Hex }}"),
	}

	SessionKeyRegistryAddresses = map[Network]common.Address{
		NetworkMainnet:     common.HexToAddress("{{ .Mainnet.SessionKeyRegistry.Hex }}"),
		NetworkCalibration: common.HexToAddress("{{ .Calibration.SessionKeyRegistry.Hex }}"),
	}
)
`))

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	fmt.Println("reading mainnet addresses...")
	mainnet, err := readAddresses(ctx, rpcMainnet, fwssMainnet)
	if err != nil {
		fmt.Fprintf(os.Stderr, "mainnet: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("  payments: %s\n", mainnet.Payments.Hex())
	fmt.Printf("  stateview: %s\n", mainnet.StateView.Hex())
	fmt.Printf("  pdpverifier: %s\n", mainnet.PDPVerifier.Hex())
	fmt.Printf("  spregistry: %s\n", mainnet.SPRegistry.Hex())
	fmt.Printf("  sessionkey: %s\n", mainnet.SessionKeyRegistry.Hex())

	fmt.Println("reading calibration addresses...")
	calibration, err := readAddresses(ctx, rpcCalibration, fwssCalibration)
	if err != nil {
		fmt.Fprintf(os.Stderr, "calibration: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("  payments: %s\n", calibration.Payments.Hex())
	fmt.Printf("  stateview: %s\n", calibration.StateView.Hex())
	fmt.Printf("  pdpverifier: %s\n", calibration.PDPVerifier.Hex())
	fmt.Printf("  spregistry: %s\n", calibration.SPRegistry.Hex())
	fmt.Printf("  sessionkey: %s\n", calibration.SessionKeyRegistry.Hex())

	// go generate runs in the package's source directory
	// if GOPACKAGE is set, we're running via go generate - output to current dir
	// otherwise output to constants/ for manual invocation from repo root
	outPath := "constants/addresses_generated.go"
	if os.Getenv("GOPACKAGE") != "" {
		outPath = "addresses_generated.go"
	}

	f, err := os.Create(outPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "create file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	err = tmpl.Execute(f, struct {
		Mainnet     *networkAddresses
		Calibration *networkAddresses
	}{
		Mainnet:     mainnet,
		Calibration: calibration,
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "execute template: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("wrote constants/addresses_generated.go")
}
